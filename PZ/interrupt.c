#include "interrupt.h"

//===========================================
//  функція переривання, низький пріоритет
//===========================================

void __interrupt(low_priority) Inter_lo(void) {
    if (TMR0IE && TMR0IF) { // any timer 0 interrupts?
        TMR0IF = 0;
        tick_t0++;
      //  TMR0ON = 0; // Стоп таймера 0
        TMR0L = TMR0L_V; //
        ADCON0bits.GODONE = 1; // старт перетворення
    }

    if (TMR1IE && TMR1IF) { // any timer 1 interrupts?
        TMR1IF = 0;
        tick_t1++;
        tick_t1_1++;
        read_key = 1;
    }
    return;
}

//===========================================
//  функція переривання, високий пріоритет
//===========================================
void __interrupt(high_priority) Inter_hi(void) {
int16_t pulse = 0, lev = t_power + err; // поточний рівень з врахуванням помилки дискретизації, виміряний на попередньому півперіоді.

    // переривання по переходу через 0
    if (INT0IE && INT0IF) {
        if (lev >= 50) pulse = 1; // Потрібно би подати імпульс, але перевіримо на постійну складову
        // Якщо pulse == 1, то подача імпульсу призведе до збільшення постійної складової. Відкладемо
        // подачу імпульсу на наступний напівперіод. Він буде іншого знаку, що призведе до зменшення
        // постійної складової
        if (ps * pulse * pp > 0) pulse = 0;
        if (pulse) {
            TRIAC = 1;
            err = lev - 100; // Рахуємо помилку для слідуючого півперіоду
        } else {
            TRIAC = 0;
            err = lev;
        }
        TMR3ON  = 1; // ввімкнути таймер 3
        ps += pp * pulse; // Рахуємо поточну постійну складову
        pp = -pp; //Наступний напівперіод буде іншого знаку 

        if (zero <= (ZERO - 1))
            zero++;
        if (getU == TRUE) {
            getU = FALSE;
            cnt_adc = 0;
            zero = 0;
        }
        INT0IF = 0;
    }

    // ADC - переривання по закінченню вимірювання АЦП
    if (ADIE && ADIF) {
        if (zero < ZERO) {
            U_meas = ((ADRESH << 8) + ADRESL);
            U_meas *= U_meas; // підносимо в квадрат
            U_summ += U_meas; // сума квадратів
            cnt_adc++;
        }

        PIR1bits.ADIF = 0;
     //   TMR0ON = 1; // Запуск таймера 0

    }



// переривання від таймера 3
    if (TMR3IE && TMR3IF){
        TMR3IF = 0;
        TRIAC = 0;   // вимкнути сімістор через 4.096мс
        TMR3ON  = 0; // вимкнути таймер 3
    }
            
    return;
}
